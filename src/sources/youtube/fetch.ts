import { mkdtemp, readdir, readFile, rm } from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { runCommand } from "../../utils/exec.js";
import { vttToPlainText } from "../../utils/vtt.js";
import type { FlatPlaylistEntry, YtDlpVideo } from "./types.js";

const YT_DLP = "yt-dlp";

type FlatPlaylist = {
	entries?: FlatPlaylistEntry[];
};

export function hasYtDlp(): boolean {
	const ytdlpPath = Bun.which(YT_DLP);
	return !!ytdlpPath;
}

export async function listVideos(
	channelId: string,
): Promise<FlatPlaylistEntry[]> {
	const url = resolveChannelUrl(channelId);

	const result = await runCommand([
		YT_DLP,
		"--flat-playlist",
		"--skip-download",
		"--dump-single-json",
		"--no-warnings",
		url,
	]);

	if (result.code !== 0) {
		throw new Error(`yt-dlp failed to list ${channelId}: ${result.stderr}`);
	}

	const data = JSON.parse(result.stdout) as FlatPlaylist;
	const entries = data.entries ?? [];
	return entries.filter((entry) => !!entry.id);
}

export async function fetchVideoDetails(
	videoUrl: string,
): Promise<YtDlpVideo | null> {
	const result = await runCommand([
		YT_DLP,
		"--dump-single-json",
		"--skip-download",
		"--no-warnings",
		videoUrl,
	]);

	if (result.code !== 0) {
		return null;
	}

	return JSON.parse(result.stdout) as YtDlpVideo;
}

export async function fetchTranscript(
	videoUrl: string,
): Promise<string | null> {
	const tempDir = await mkdtemp(path.join(os.tmpdir(), "trustmebro-yt-"));
	try {
		// Try manual subtitles first with multiple format fallbacks
		const manualResult = await downloadSubtitles(videoUrl, tempDir, false);
		if (manualResult) {
			return manualResult;
		}

		// Fall back to auto-generated captions
		const autoResult = await downloadSubtitles(videoUrl, tempDir, true);
		return autoResult;
	} finally {
		await rm(tempDir, { recursive: true, force: true });
	}
}

/** Download subtitles using yt-dlp with format fallbacks */
async function downloadSubtitles(
	videoUrl: string,
	workingDir: string,
	autoGenerated: boolean,
): Promise<string | null> {
	const outputTemplate = path.join(workingDir, "transcript");

	// Format priority with comprehensive fallbacks
	// vtt/srt/json3 are the most reliable, followed by ttml and srv formats
	const subFormat = "vtt/srt/json3/ttml/srv3/srv2/srv1";

	const args = [
		YT_DLP,
		autoGenerated ? "--write-auto-sub" : "--write-sub",
		"--skip-download",
		"--sub-langs",
		"en.*,en", // Try English variants, then fallback to plain 'en'
		"--sub-format",
		subFormat,
		"--output",
		outputTemplate,
		videoUrl,
	];

	const result = await runCommand(args);

	if (result.code !== 0) {
		return null;
	}

	// Find and parse any subtitle file
	const subtitleFile = await findSubtitleFile(workingDir);
	if (!subtitleFile) {
		return null;
	}

	const content = await readFile(subtitleFile.path, "utf8");

	// Parse based on format
	if (subtitleFile.ext === "json3") {
		return parseJson3(content);
	}

	// For VTT, SRT, TTML, and similar text-based formats
	const text = vttToPlainText(content);
	return text.trim() || null;
}

/** Find any subtitle file in the directory */
async function findSubtitleFile(
	workingDir: string,
): Promise<{ path: string; ext: string } | null> {
	const files = await readdir(workingDir);

	// Priority order for formats
	const formatPriority = ["vtt", "srt", "json3", "ttml", "srv3", "srv2", "srv1"];

	for (const ext of formatPriority) {
		const file = files.find((f) => f.endsWith(`.${ext}`));
		if (file) {
			return { path: path.join(workingDir, file), ext };
		}
	}

	return null;
}

/** Parse YouTube's json3 subtitle format */
function parseJson3(content: string): string | null {
	try {
		const data = JSON.parse(content) as {
			events?: Array<{ segs?: Array<{ utf8?: string }> }>;
		};

		if (!data.events) return null;

		const textParts: string[] = [];
		for (const event of data.events) {
			if (event.segs) {
				for (const seg of event.segs) {
					if (seg.utf8 && seg.utf8.trim() !== "\n") {
						textParts.push(seg.utf8);
					}
				}
			}
		}

		const text = textParts.join("");
		return text.trim() || null;
	} catch {
		return null;
	}
}

export function buildVideoUrl(entry: FlatPlaylistEntry): string {
	if (entry.url) return entry.url;
	if (entry.id) return `https://www.youtube.com/watch?v=${entry.id}`;
	return "";
}

function resolveChannelUrl(channelId: string): string {
	if (channelId.startsWith("http://") || channelId.startsWith("https://")) {
		return channelId;
	}
	if (channelId.startsWith("@")) {
		return `https://www.youtube.com/${channelId}/videos`;
	}
	if (channelId.startsWith("UC")) {
		return `https://www.youtube.com/channel/${channelId}/videos`;
	}
	return `https://www.youtube.com/@${channelId}/videos`;
}
