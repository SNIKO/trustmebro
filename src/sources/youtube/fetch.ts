import { execFileSync } from "node:child_process";
import { mkdtemp, readdir, readFile, rm } from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { runCommand } from "../../utils/exec.js";
import { vttToPlainText } from "../../utils/vtt.js";
import type { FlatPlaylistEntry, YtDlpVideo } from "./types.js";

const YT_DLP = "yt-dlp";

type FlatPlaylist = {
	entries?: FlatPlaylistEntry[];
};

export function hasYtDlp(): boolean {
	try {
		execFileSync("which", [YT_DLP], { stdio: "pipe" });
		return true;
	} catch {
		return false;
	}
}

export async function listVideos(
	channelId: string,
): Promise<FlatPlaylistEntry[]> {
	const url = resolveChannelUrl(channelId);

	const result = await runCommand([
		YT_DLP,
		"--flat-playlist",
		"--skip-download",
		"--dump-single-json",
		"--no-warnings",
		url,
	]);

	if (result.code !== 0) {
		throw new Error(`yt-dlp failed to list ${channelId}: ${result.stderr}`);
	}

	const data = JSON.parse(result.stdout) as FlatPlaylist;
	const entries = data.entries ?? [];
	return entries.filter((entry) => !!entry.id);
}

export type VideoDetailsResult =
	| { ok: true; details: YtDlpVideo }
	| { ok: false; reason: "members only" | "yt-dlp-failed"; message?: string };

export async function fetchVideoDetails(
	videoUrl: string,
): Promise<VideoDetailsResult> {
	const result = await runCommand([
		YT_DLP,
		"--dump-single-json",
		"--skip-download",
		"--no-warnings",
		videoUrl,
	]);

	if (result.code !== 0) {
		const combined = `${result.stderr}\n${result.stdout}`.toLowerCase();
		if (
			combined.includes("members-only") ||
			combined.includes("members only")
		) {
			return { ok: false, reason: "members only", message: result.stderr };
		}
		return { ok: false, reason: "yt-dlp-failed", message: result.stderr };
	}

	return { ok: true, details: JSON.parse(result.stdout) as YtDlpVideo };
}

export async function fetchTranscript(
	videoUrl: string,
	details?: YtDlpVideo,
): Promise<string | null> {
	const tempDir = await mkdtemp(path.join(os.tmpdir(), "trustmebro-yt-"));
	try {
		const langs = getLanguagePriority(details);
		// Try manual subtitles first
		const manualResult = await downloadSubtitles(
			videoUrl,
			tempDir,
			false,
			langs,
		);
		if (manualResult) {
			return manualResult;
		}

		// Fall back to auto-generated captions
		const autoResult = await downloadSubtitles(videoUrl, tempDir, true, langs);
		return autoResult;
	} finally {
		await rm(tempDir, { recursive: true, force: true });
	}
}

function getLanguagePriority(details?: YtDlpVideo): string {
	const parts: string[] = [];
	if (details?.language) {
		parts.push(`${details.language}.*`);
		parts.push(details.language);
	}
	parts.push("en.*", "en");
	return parts.join(",");
}

/** Download subtitles using yt-dlp with format fallbacks */
async function downloadSubtitles(
	videoUrl: string,
	workingDir: string,
	autoGenerated: boolean,
	langs: string,
): Promise<string | null> {
	const outputTemplate = path.join(workingDir, "transcript");

	// Format priority with comprehensive fallbacks
	// vtt/srt/json3 are the most reliable, followed by ttml and srv formats
	const subFormat = "vtt/srt/json3/ttml/srv3/srv2/srv1";

	const args = [
		YT_DLP,
		"--ignore-errors",
		autoGenerated ? "--write-auto-sub" : "--write-sub",
		"--skip-download",
		"--sub-langs",
		langs,
		"--sub-format",
		subFormat,
		"--output",
		outputTemplate,
		videoUrl,
	];

	const result = await runCommand(args);

	if (result.code !== 0) {
		return null;
	}

	// Find and parse any subtitle file
	const subtitleFile = await findSubtitleFile(workingDir, langs);
	if (!subtitleFile) {
		return null;
	}

	const content = await readFile(subtitleFile.path, "utf8");

	// Parse based on format
	if (subtitleFile.ext === "json3") {
		return parseJson3(content);
	}

	// For VTT, SRT, TTML, and similar text-based formats
	const text = vttToPlainText(content);
	return text.trim() || null;
}

/** Find any subtitle file in the directory */
async function findSubtitleFile(
	workingDir: string,
	langsStr: string,
): Promise<{ path: string; ext: string } | null> {
	const files = await readdir(workingDir);

	// Priority order for formats
	const formatPriority = [
		"vtt",
		"srt",
		"json3",
		"ttml",
		"srv3",
		"srv2",
		"srv1",
	];
	// Parse language priority from the string passed to yt-dlp
	// We want to try finding files that match the requested languages in order
	// e.g. "ru.*,ru,en.*,en" -> try matching files with .ru., .en.
	const prefLangs = langsStr.split(",").map((l) => l.replace(".*", ""));

	for (const ext of formatPriority) {
		const matchingFiles = files.filter((f) => f.endsWith(`.${ext}`));
		if (matchingFiles.length === 0) continue;

		// 1. Try preferred languages in order
		for (const lang of prefLangs) {
			const match = matchingFiles.find((f) => {
				// Match .lang. (e.g. .ru.)
				if (f.includes(`.${lang}.`)) return true;
				// Match .lang- (e.g. .ru-orig, .ru-RU)
				if (f.includes(`.${lang}-`)) return true;
				// Match exact end .lang.ext
				if (f.endsWith(`.${lang}.${ext}`)) return true;
				return false;
			});
			if (match) {
				return { path: path.join(workingDir, match), ext };
			}
		}

		// 2. Fallback to any available
		// biome-ignore lint/style/noNonNullAssertion: Guaranteed by check above
		return { path: path.join(workingDir, matchingFiles[0]!), ext };
	}

	return null;
}

/** Parse YouTube's json3 subtitle format */
function parseJson3(content: string): string | null {
	try {
		const data = JSON.parse(content) as {
			events?: Array<{ segs?: Array<{ utf8?: string }> }>;
		};

		if (!data.events) return null;

		const textParts: string[] = [];
		for (const event of data.events) {
			if (event.segs) {
				for (const seg of event.segs) {
					if (seg.utf8 && seg.utf8.trim() !== "\n") {
						textParts.push(seg.utf8);
					}
				}
			}
		}

		const text = textParts.join("");
		return text.trim() || null;
	} catch {
		return null;
	}
}

export function buildVideoUrl(entry: FlatPlaylistEntry): string {
	if (entry.url) return entry.url;
	if (entry.id) return `https://www.youtube.com/watch?v=${entry.id}`;
	return "";
}

function resolveChannelUrl(channelId: string): string {
	if (channelId.startsWith("http://") || channelId.startsWith("https://")) {
		return channelId;
	}
	if (channelId.startsWith("@")) {
		return `https://www.youtube.com/${channelId}/videos`;
	}
	if (channelId.startsWith("UC")) {
		return `https://www.youtube.com/channel/${channelId}/videos`;
	}
	return `https://www.youtube.com/@${channelId}/videos`;
}
